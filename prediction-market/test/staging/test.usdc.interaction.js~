const { expect } = require("chai");
const { ethers, network } = require("hardhat");
const { networkConfig, developmentChains } = require("../../helper-hardhat-config");

network.name === "hardhat"
    ? describe("PredictionMarket Staging Tests", function () {
        let market, usdc, factory;
        let owner, alice;

        beforeEach(async function () {
            [owner, alice] = await ethers.getSigners();
            const chainId = network.config.chainId;
            const usdcAddress = networkConfig[network.config.chainId].usdcAddress;

            // We need to have some USDC on the forked network
            usdc = await ethers.getContractAt("MintableERC20", usdcAddress);

            // Deploy Factory
            const PredictionMarketFactory = await ethers.getContractFactory("PredictionMarketFactory");
            factory = await PredictionMarketFactory.deploy();
            await factory.waitForDeployment();

            // The owner creates a market
            const marketAddress = await factory.connect(owner).createMarket.staticCall(
                "Will ETH reach $5000 by end of year?",
                2, // CRYPTO
                owner.address, // Using owner as oracle for simplicity
                usdcAddress,
                "Yes Token", "YES", "No Token", "NO"
            );

            await factory.createMarket(
                "Will ETH reach $5000 by end of year?",
                2, // CRYPTO
                owner.address,
                usdcAddress,
                "Yes Token", "YES", "No Token", "NO"
            );

            market = await ethers.getContractAt("PredictionMarket", marketAddress);

            // Impersonate a USDC holder to get some USDC for alice
            const usdcHolderAddress = "0x47ac0Fb4F2D84898e4D9E7b4DaB3C24507a6D503"; // A known USDC whale
            await network.provider.request({
                method: "hardhat_impersonateAccount",
                params: [usdcHolderAddress],
            });
            const usdcHolder = await ethers.getSigner(usdcHolderAddress);

            // Send some ETH to the USDC holder for gas
            await owner.sendTransaction({
                to: usdcHolderAddress,
                value: ethers.parseEther("1.0"),
            });

            await usdc.connect(usdcHolder).transfer(alice.address, ethers.parseUnits("10", 6));
            await network.provider.request({
                method: "hardhat_stopImpersonatingAccount",
                params: [usdcHolderAddress],
            });

            await usdc.connect(alice).approve(marketAddress, ethers.parseUnits("10", 6));
        });

        it("should be able to accept a bet using the non-mock USDC token", async function () {
            const betAmount = ethers.parseUnits("1", 6); // 1 USDC
            
            const aliceUsdcBalance = await usdc.balanceOf(alice.address);
            console.log(`Alice's USDC balance on forked network: ${ethers.formatUnits(aliceUsdcBalance, 6)} USDC`);

            if (aliceUsdcBalance >= betAmount) {
                await expect(market.connect(alice).bet(betAmount, true)).to.not.be.reverted;
            } else {
                console.log("Skipping bet execution: Alice has insufficient USDC balance on the forked network.");
                this.skip();
            }
        });
    })
    : describe.skip;
